<!DOCTYPE html>
<html lang="en"><head><meta charset="UTF-8"/><meta name="viewport" content="width=device-width, initial-scale=1.0"/><title>Concepts ¬∑ TulipaClustering.jl</title><meta name="title" content="Concepts ¬∑ TulipaClustering.jl"/><meta property="og:title" content="Concepts ¬∑ TulipaClustering.jl"/><meta property="twitter:title" content="Concepts ¬∑ TulipaClustering.jl"/><meta name="description" content="Documentation for TulipaClustering.jl."/><meta property="og:description" content="Documentation for TulipaClustering.jl."/><meta property="twitter:description" content="Documentation for TulipaClustering.jl."/><meta property="og:url" content="https://TulipaEnergy.github.io/TulipaClustering.jl/20-concepts/"/><meta property="twitter:url" content="https://TulipaEnergy.github.io/TulipaClustering.jl/20-concepts/"/><link rel="canonical" href="https://TulipaEnergy.github.io/TulipaClustering.jl/20-concepts/"/><script data-outdated-warner src="../assets/warner.js"></script><link href="https://cdnjs.cloudflare.com/ajax/libs/lato-font/3.0.0/css/lato-font.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/juliamono/0.050/juliamono.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/fontawesome.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/solid.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.2/css/brands.min.css" rel="stylesheet" type="text/css"/><link href="https://cdnjs.cloudflare.com/ajax/libs/KaTeX/0.16.8/katex.min.css" rel="stylesheet" type="text/css"/><script>documenterBaseURL=".."</script><script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.6/require.min.js" data-main="../assets/documenter.js"></script><script src="../search_index.js"></script><script src="../siteinfo.js"></script><script src="../../versions.js"></script><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-mocha.css" data-theme-name="catppuccin-mocha"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-macchiato.css" data-theme-name="catppuccin-macchiato"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-frappe.css" data-theme-name="catppuccin-frappe"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/catppuccin-latte.css" data-theme-name="catppuccin-latte"/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-dark.css" data-theme-name="documenter-dark" data-theme-primary-dark/><link class="docs-theme-link" rel="stylesheet" type="text/css" href="../assets/themes/documenter-light.css" data-theme-name="documenter-light" data-theme-primary/><script src="../assets/themeswap.js"></script></head><body><div id="documenter"><nav class="docs-sidebar"><a class="docs-logo" href="../"><img src="../assets/logo.png" alt="TulipaClustering.jl logo"/></a><div class="docs-package-name"><span class="docs-autofit"><a href="../">TulipaClustering.jl</a></span></div><button class="docs-search-query input is-rounded is-small is-clickable my-2 mx-auto py-1 px-2" id="documenter-search-query">Search docs (Ctrl + /)</button><ul class="docs-menu"><li><a class="tocitem" href="../">Welcome</a></li><li><a class="tocitem" href="../10-tutorial/">Tutorial</a></li><li class="is-active"><a class="tocitem" href>Concepts</a><ul class="internal"><li><a class="tocitem" href="#Clustering-Methods"><span>Clustering Methods</span></a></li><li><a class="tocitem" href="#weight-fitting"><span>Weight Fitting</span></a></li><li><a class="tocitem" href="#Euclidean-Distance-vs-Dissimilarity"><span>Euclidean Distance vs Dissimilarity</span></a></li><li><a class="tocitem" href="#Clustering-Per-or-Across"><span>Clustering Per or Across</span></a></li></ul></li><li><a class="tocitem" href="../80-scientific-references/">Scientific References</a></li><li><a class="tocitem" href="../90-contributing/">Contributing guidelines</a></li><li><a class="tocitem" href="../91-developer/">Developer documentation</a></li><li><a class="tocitem" href="../95-reference/">Reference</a></li></ul><div class="docs-version-selector field has-addons"><div class="control"><span class="docs-label button is-static is-size-7">Version</span></div><div class="docs-selector control is-expanded"><div class="select is-fullwidth is-size-7"><select id="documenter-version-selector"></select></div></div></div></nav><div class="docs-main"><header class="docs-navbar"><a class="docs-sidebar-button docs-navbar-link fa-solid fa-bars is-hidden-desktop" id="documenter-sidebar-button" href="#"></a><nav class="breadcrumb"><ul class="is-hidden-mobile"><li class="is-active"><a href>Concepts</a></li></ul><ul class="is-hidden-tablet"><li class="is-active"><a href>Concepts</a></li></ul></nav><div class="docs-right"><a class="docs-navbar-link" href="https://github.com/TulipaEnergy/TulipaClustering.jl/blob/main/docs/src/20-concepts.md#" title="Edit source on GitHub"><span class="docs-icon fa-solid">ÔÅÑ</span></a><a class="docs-settings-button docs-navbar-link fa-solid fa-gear" id="documenter-settings-button" href="#" title="Settings"></a><a class="docs-article-toggle-button fa-solid fa-chevron-up" id="documenter-article-toggle-button" href="javascript:;" title="Collapse all docstrings"></a></div></header><article class="content" id="documenter-page"><h1 id="concepts"><a class="docs-heading-anchor" href="#concepts">Concepts</a><a id="concepts-1"></a><a class="docs-heading-anchor-permalink" href="#concepts" title="Permalink"></a></h1><p>The growing integration of renewable energy sources into energy systems requires planning models to account for not only demand variability but also fluctuations in renewable availability during operational periods. Capturing this temporal detail over long planning horizons can be computationally demanding or even intractable. For instance, the following figure shows the availability profile of three technologies and four different countries for the first day of each month of the year.</p><p><img src="../assets/renewable-availability-time-series.png" alt="Renewable availability time series"/></p><p>A common approach to address this challenge is to approximate the problem using a reduced set of selected periods, known as representative periods (RPs). The RPs refers to specific time periods, such as days or weeks, selected to capture the variability and characteristics of the energy system over an extended period, such as a year. The core idea is that many of the periods are similar to each other; such that the solutions are also similar and we do not have to solve all of them and get an approximation from the solutions of the RPs.</p><p><img src="../assets/periods-to-rps.png" alt="From base periods to representative periods"/></p><p>To simplify, let&#39;s consider a single profile, for a single year. Let&#39;s denote it as <span>$p_i$</span>, where <span>$i = 1,\dots,N$</span>. The clustering process consists of:</p><ol><li><p>Split <code>N</code> into (let&#39;s assume equal) <em>periods</em> of size <code>m = period_duration</code>. We can rename <span>$p_i$</span> as</p><p class="math-container">\[p_{j,k}, \qquad \text{where} \qquad j = 1,\dots,m, \quad k = 1,\dots,N/m.\]</p></li><li><p>Compute <code>L = num_rps</code> representative periods</p><p class="math-container">\[r_{j,\ell}, \qquad \text{where} \qquad j = 1,\dots,m, \quad \ell = 1,\dots,L.\]</p></li><li><p>During computation of the representative periods, we obtained weight <span>$w_{k,\ell}$</span> between the period <span>$k$</span> and the representative period <span>$\ell$</span>, such that</p><p class="math-container">\[p_{j,k} = \sum_{\ell = 1}^{L} r_{j,\ell} \ w_{k,\ell}, \qquad \forall j = 1,\dots,m, \quad k = 1,\dots,N/m\]</p><p>The weight <span>$w_{k,\ell}$</span> maps the representative periods to the base periods (or original periods).</p></li></ol><h2 id="Clustering-Methods"><a class="docs-heading-anchor" href="#Clustering-Methods">Clustering Methods</a><a id="Clustering-Methods-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-Methods" title="Permalink"></a></h2><p>Representative periods are typically chosen using clustering methods. One common approach is <code>k-means</code>, where the representative period values, or centroids, are calculated as the average of all base periods within the cluster. Another common method is <code>k-medoids</code>, in which the representative period is an actual data point from the cluster.</p><p>The <code>method</code> parameter in the function <a href="../95-reference/#TulipaClustering.cluster!-Tuple{Any, Any, Any}"><code>cluster!</code></a> allows to select <code>:k-means</code> and <code>:k-medoids</code> as clustering methods. However, for better approximation, <code>TulipaClustering</code> also allows three more different clustering methods to choose representative periods that form the hull of the dataset: <code>:convex_hull</code>, <code>:convex_hull_with_null</code>, and <code>:conical_hull</code>. Although the hull clustering can be combined with different <a href="#weight-fitting">weight types</a>, the choice of weight type determines the kind of hull within which the original periods must lie in order to be exactly reconstructible. Specifically:</p><ul><li><code>:convex_hull</code>: For convex weights, the original periods must lie within the convex hull of the representative periods. This is the smallest convex set containing them.</li><li><code>:convex_hull_with_null</code>: For sub-unit conic weights, reconstruction is possible if the original periods lie within the convex hull of the representative periods and the origin (null). Intuitively, this corresponds to finding convex weights that may assign some mass to a null (zero) vector. After discarding the null, the remaining positive weights sum to less than one, hence sub-unit.</li><li><code>:conical_hull</code>: For general conic weights, the reconstruction is valid as long as the original periods lie within the conic hull of the RPs.</li></ul><p>We illustrate the differences between these hulls in the following figure, where each successive hull type expands the space in which the original data points can be expressed using the RPs without introducing a projection error. The figure shows the geometric interpretation of different hull types. A set of base period data (dots) is shown, and the shaded region indicates the span of each hull. Even when blended weights are used, this choice of RPs introduces projection errors. The more general the hull type is, the fewer RPs cover the dataset.</p><p><img src="../assets/hulls-types.png" alt="Hull Types"/></p><p>For more details on the hull types, check the <a href="../80-scientific-references/#scientific-refs">scientific references</a> section.</p><h2 id="weight-fitting"><a class="docs-heading-anchor" href="#weight-fitting">Weight Fitting</a><a id="weight-fitting-1"></a><a class="docs-heading-anchor-permalink" href="#weight-fitting" title="Permalink"></a></h2><p>After the clustering is done, each period is assigned to one representative period. We call this a &quot;Dirac assignment&quot; after the Dirac measure: a measure that is concentrated on one item (i.e., one base period is mapped into exactly one representative period).</p><p><img src="../assets/dirac-weights.png" alt="Dirac assignment"/></p><p><code>TulipaClustering</code> supports blended weights for representative periods, meaning that the weigths can be positive fractional numbers.</p><p><img src="../assets/blended-weights.png" alt="Blended weights"/></p><p>To produce these, we use projected gradient descent. For more details on the blended weights, check the <a href="../80-scientific-references/#scientific-refs">scientific references</a> section.</p><p>The <code>weight_type</code> parameter in the function <a href="../95-reference/#TulipaClustering.cluster!-Tuple{Any, Any, Any}"><code>cluster!</code></a> allows to select different ways to select the weights:</p><ul><li><code>:conical</code> weights are positive. The projection is onto a conic hull of the RPs.</li><li><code>:conical_bounded</code> also known as sub-unit conic, weights are positive, add at most into one. The projection is onto a convex hull of the RPs.</li></ul><p>and the origin.</p><ul><li><code>:convex</code> weights are positive, add into one. The projection is onto a convex hull of the RPs.</li><li><code>:dirac</code> one unit weight and the rest are zeros. Periods are projected onto a discrete set of representative periods.</li></ul><p>The order here is from less restrictive to more restrictive.</p><p>The following figure shows the projection errors when approximating base period data using different weight types. Orange areas show the spaces of all points which can be represented without introducing a projection error. Errors decrease from left to right as we move from a discrete Dirac to more general weight types.</p><p><img src="../assets/weight-types.png" alt="Weight Types"/></p><h2 id="Euclidean-Distance-vs-Dissimilarity"><a class="docs-heading-anchor" href="#Euclidean-Distance-vs-Dissimilarity">Euclidean Distance vs Dissimilarity</a><a id="Euclidean-Distance-vs-Dissimilarity-1"></a><a class="docs-heading-anchor-permalink" href="#Euclidean-Distance-vs-Dissimilarity" title="Permalink"></a></h2><p>The <code>distance</code> parameter in the function <a href="../95-reference/#TulipaClustering.cluster!-Tuple{Any, Any, Any}"><code>cluster!</code></a> defines the metric used to measure how different the datapoints are. The parameter recieves any metric from the package <a href="https://github.com/JuliaStats/Distances.jl">Distances.jl</a>. By default it uses, euclidean distance, meaning that we seek the closest point in the convex hull by calculating the absolute distance. For instance, in the following figure, both points (2,3) and (3,6) is possible to find weights so that its error is smaller when projected to the hull.</p><p><img src="../assets/euclidian-distance.png" alt="Euclidian Distance"/></p><p>Nevertheless, when using the hull clustering, we want to measure dissimilarity so that:</p><p class="math-container">\[d(ùëéùë•, ùëèùë¶) = d(ùë•, ùë¶) \quad \text{if} \quad ùëé,ùëè ‚àà ‚Ñù+\]</p><p>.</p><p>In other words, we want to measure distance to rays, i.e., angular difference, instead of points. So, why cosine distance? because it meassures the angular distance and it remains the same no matter the magnitude of the data point:</p><p class="math-container">\[d_{cos}(ùëéùë•, ùëèùë¶) = d_{cos}(ùë•, ùë¶) \quad \text{if} \quad ùëé, ùëè ‚àà ‚Ñù+\]</p><p><img src="../assets/cosine-distance.png" alt="Cosine Distance"/></p><h2 id="Clustering-Per-or-Across"><a class="docs-heading-anchor" href="#Clustering-Per-or-Across">Clustering Per or Across</a><a id="Clustering-Per-or-Across-1"></a><a class="docs-heading-anchor-permalink" href="#Clustering-Per-or-Across" title="Permalink"></a></h2><p>The <a href="../95-reference/#TulipaClustering.ProfilesTableLayout"><code>ProfilesTableLayout</code></a> parameter in the function <a href="../95-reference/#TulipaClustering.cluster!-Tuple{Any, Any, Any}"><code>cluster!</code></a> allows users to include <code>cols_to_groupby</code> for the clustering process. By default, all profiles will be clustered by the column <code>:year</code>, meaning that the representatives will be calculated per year. We recommend this approach because it is expected that renewable profiles will change over time due to advancements in technology. However, if the user prefers to have representative periods across multiple years, they simply need to provide an empty vector for <code>cols_to_groupby</code> in the <a href="../95-reference/#TulipaClustering.ProfilesTableLayout"><code>ProfilesTableLayout</code></a>.</p><p>In addition, if the profiles to cluster have the column <code>:scenario</code> (or similar name), it can be added to the <code>cols_to_groupby</code> parameter in order to obtain representative periods per scenario. If the column is in the input profiles, but it is not included in the columns to group by, then by default the representative periods will be calculated across the scenario. In the following sections, we discuss more on each case.</p><h3 id="Per-Scenario"><a class="docs-heading-anchor" href="#Per-Scenario">Per Scenario</a><a id="Per-Scenario-1"></a><a class="docs-heading-anchor-permalink" href="#Per-Scenario" title="Permalink"></a></h3><p>In this approach, representative periods are chosen separately for each scenario. This involves applying the steps of normalization, selection, and weight calculation to each scenario individually. As a result, each scenario has its own set of representative periods (RPs) that capture all periods within that scenario.</p><p>The following figure illustrates the concept of scenario-specific representative periods. For instance, the high scenario has its own representative periods labeled RPs High 1 and High 2, the medium scenario has RPs Medium 1 and Medium 2, and the low scenario features RPs Low 1 and Low 2. These representative periods are used to approximate the original periods within each scenario.</p><p><img src="../assets/per-scenario.png" alt="per-scenario"/></p><p>One advantage of this approach is that the clustering task is performed on smaller, more homogeneous sets. However, this separation also means that similar patterns across different scenarios may be ignored. As a result, the union of all representatives, may include redundant or highly similar periods that increase the model size without adding new information.</p><h3 id="Across-Scenarios"><a class="docs-heading-anchor" href="#Across-Scenarios">Across Scenarios</a><a id="Across-Scenarios-1"></a><a class="docs-heading-anchor-permalink" href="#Across-Scenarios" title="Permalink"></a></h3><p>To better capture the overall structure of the full scenario space, we propose to calculate the representative across scenarios. Here, representative periods are selected from the combined set of periods across all scenarios, resulting in a single, scenario independent set of RPs. This approach allows us to identify a smaller set of representative periods that generalizes well across different scenarios, reducing redundancy and potentially improving model compactness.</p><p>The key idea is to perform clustering on the full joint set of scenarios. The selection process thus considers the joint variability in demand and availability across all scenarios. This enables the model to reuse the same representative periods in multiple scenarios, rather than duplicating similar patterns. In this approach, the weights reflect how many original periods across all scenarios are best represented by each RP.</p><p>The following figure illustrates the concept of representative periods across scenarios. Here, representative periods 1 to 6 are selected from the combined set of periods across all scenarios. These representative periods are then used to approximate the original periods in each scenario.</p><p><img src="../assets/across-scenarios.png" alt="across-scenarios"/></p><p>An advantage of this approach is its ability to minimize redundancy by recognizing similarities between periods in different scenarios. This can lead to a more efficient representation of uncertainty, especially when common temporal patterns exist across the scenario set. However, it also requires more computational effort during the selection phase.</p></article><nav class="docs-footer"><a class="docs-footer-prevpage" href="../10-tutorial/">¬´ Tutorial</a><a class="docs-footer-nextpage" href="../80-scientific-references/">Scientific References ¬ª</a><div class="flexbox-break"></div><p class="footer-message">Powered by <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> and the <a href="https://julialang.org/">Julia Programming Language</a>.</p></nav></div><div class="modal" id="documenter-settings"><div class="modal-background"></div><div class="modal-card"><header class="modal-card-head"><p class="modal-card-title">Settings</p><button class="delete"></button></header><section class="modal-card-body"><p><label class="label">Theme</label><div class="select"><select id="documenter-themepicker"><option value="auto">Automatic (OS)</option><option value="documenter-light">documenter-light</option><option value="documenter-dark">documenter-dark</option><option value="catppuccin-latte">catppuccin-latte</option><option value="catppuccin-frappe">catppuccin-frappe</option><option value="catppuccin-macchiato">catppuccin-macchiato</option><option value="catppuccin-mocha">catppuccin-mocha</option></select></div></p><hr/><p>This document was generated with <a href="https://github.com/JuliaDocs/Documenter.jl">Documenter.jl</a> version 1.14.1 on <span class="colophon-date" title="Monday 13 October 2025 14:53">Monday 13 October 2025</span>. Using Julia version 1.12.0.</p></section><footer class="modal-card-foot"></footer></div></div></div></body></html>
